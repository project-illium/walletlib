// Copyright (c) 2022 The illium developers
// Use of this source code is governed by an MIT
// license that can be found in the LICENSE file.

package walletlib

import (
	"bytes"
	"context"
	"crypto/aes"
	"crypto/cipher"
	"crypto/sha512"
	"encoding/binary"
	"errors"
	"github.com/ipfs/go-datastore"
	"github.com/ipfs/go-datastore/query"
	"github.com/libp2p/go-libp2p/core/crypto"
	icrypto "github.com/project-illium/ilxd/crypto"
	"github.com/project-illium/ilxd/params"
	"github.com/project-illium/ilxd/repo"
	"github.com/project-illium/ilxd/types"
	"github.com/tyler-smith/go-bip39"
	"golang.org/x/crypto/pbkdf2"
	"math/rand"
	"strconv"
	"strings"
	"sync"
	"time"
)

var (
	ErrUninitializedKeychain = errors.New("keychain uninitialized")
	ErrEncryptedKeychain     = errors.New("keychain encrypted")
	ErrPublicOnlyKeychain    = errors.New("keychain public only")

	mockBasicUnlockScriptCommitment = bytes.Repeat([]byte{0xff}, 32)
)

const (
	// defaultKdfRounds is the number of rounds to use when generating the
	// encryption key. The greater this number is, the harder it is to
	// brute force the encryption key.
	defaultKdfRounds = 8192

	// defaultKeyLength is the encryption key length generated by pbkdf2.
	defaultKeyLength = 32
)

type indexedViewKey struct {
	key   *icrypto.Curve25519PrivateKey
	index uint32
}

type Keychain struct {
	ds              repo.Datastore
	params          *params.NetworkParams
	viewKeys        []*indexedViewKey
	unencryptedSeed []byte

	isEncrypted bool
	isPruned    bool
	mtx         sync.RWMutex
}

func NewKeychain(ds repo.Datastore, params *params.NetworkParams, mnemonic string) (*Keychain, error) {
	if err := ds.Put(context.Background(), datastore.NewKey(MnemonicSeedDatastoreKey), []byte(mnemonic)); err != nil {
		return nil, err
	}

	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, 0)
	if err := ds.Put(context.Background(), datastore.NewKey(AddressIndexDatastoreKey), b); err != nil {
		return nil, err
	}

	viewMaster, err := seedToViewMaster(bip39.NewSeed(mnemonic, ""))
	if err != nil {
		return nil, err
	}
	viewChild0, err := viewMaster.Child(0)
	if err != nil {
		return nil, err
	}

	curveChild0, ok := viewChild0.PrivKey.(*icrypto.Curve25519PrivateKey)
	if !ok {
		return nil, errors.New("error converting hdkey to curve25519")
	}

	ser, err := crypto.MarshalPrivateKey(viewChild0)
	if err != nil {
		return nil, err
	}
	if err := ds.Put(context.Background(), datastore.NewKey(ViewKeyDatastoreKeyPrefix+"0"), ser); err != nil {
		return nil, err
	}

	salt := make([]byte, 32)
	rand.Read(salt)
	if err := ds.Put(context.Background(), datastore.NewKey(KeyDatastoreSaltKey), salt); err != nil {
		return nil, err
	}

	return &Keychain{
		ds:       ds,
		params:   params,
		viewKeys: []*indexedViewKey{{curveChild0, 0}},
		mtx:      sync.RWMutex{},
	}, nil
}

func LoadKeychain(ds repo.Datastore, params *params.NetworkParams) (*Keychain, error) {
	q := query.Query{
		Prefix: ViewKeyDatastoreKeyPrefix,
	}
	results, err := ds.Query(context.Background(), q)
	if err != nil {
		return nil, err
	}

	viewKeys := make([]*indexedViewKey, 0)
	for result, ok := results.NextSync(); ok; {
		indexStr := strings.Split(result.Key, "/")
		index, err := strconv.Atoi(indexStr[len(indexStr)-1])
		if err != nil {
			return nil, err
		}
		key, err := crypto.UnmarshalPrivateKey(result.Value)
		if err != nil {
			return nil, err
		}
		curveKey, ok := key.(*icrypto.Curve25519PrivateKey)
		if !ok {
			return nil, errors.New("error converting hdkey to curve25519")
		}
		viewKeys = append(viewKeys, &indexedViewKey{
			key:   curveKey,
			index: uint32(index),
		})
	}
	if len(viewKeys) == 0 {
		return nil, ErrUninitializedKeychain
	}

	return &Keychain{
		ds:       ds,
		params:   params,
		viewKeys: viewKeys,
		mtx:      sync.RWMutex{},
	}, nil
}

func (kc *Keychain) Address() (Address, error) {
	kc.mtx.RLock()
	defer kc.mtx.RUnlock()

	indexBytes, err := kc.ds.Get(context.Background(), datastore.NewKey(AddressIndexDatastoreKey))
	if err != nil {
		return nil, err
	}
	index := binary.BigEndian.Uint32(indexBytes)

	mnemonic, err := kc.ds.Get(context.Background(), datastore.NewKey(MnemonicSeedDatastoreKey))
	if err != nil {
		return nil, err
	}

	seed := bip39.NewSeed(string(mnemonic), "")
	spendMaster, err := seedToSpendMaster(seed)
	if err != nil {
		return nil, err
	}
	childSpendKey, err := spendMaster.Child(index)
	if err != nil {
		return nil, err
	}
	rawPublic, err := childSpendKey.GetPublic().Raw()
	if err != nil {
		return nil, err
	}

	viewMaster, err := seedToViewMaster(seed)
	if err != nil {
		return nil, err
	}
	childViewKey, err := viewMaster.Child(index)
	if err != nil {
		return nil, err
	}

	script := types.UnlockingScript{
		SnarkVerificationKey: mockBasicUnlockScriptCommitment,
		PublicParams:         [][]byte{rawPublic},
	}

	return NewBasicAddress(script, childViewKey.PrivateKey().GetPublic(), kc.params)
}

func (kc *Keychain) NewAddress() (Address, error) {
	kc.mtx.Lock()
	defer kc.mtx.Unlock()

	if kc.isPruned {
		return nil, ErrPublicOnlyKeychain
	}
	if kc.isEncrypted {
		return nil, ErrEncryptedKeychain
	}

	indexBytes, err := kc.ds.Get(context.Background(), datastore.NewKey(AddressIndexDatastoreKey))
	if err != nil {
		return nil, err
	}
	nextIndex := binary.BigEndian.Uint32(indexBytes) + 1

	spendMaster, err := seedToSpendMaster(kc.unencryptedSeed)
	if err != nil {
		return nil, err
	}
	childSpendKey, err := spendMaster.Child(nextIndex)
	if err != nil {
		return nil, err
	}
	rawPublic, err := childSpendKey.GetPublic().Raw()
	if err != nil {
		return nil, err
	}

	viewMaster, err := seedToViewMaster(kc.unencryptedSeed)
	if err != nil {
		return nil, err
	}
	childViewKey, err := viewMaster.Child(nextIndex)
	if err != nil {
		return nil, err
	}
	curveViewKey, ok := childViewKey.PrivKey.(*icrypto.Curve25519PrivateKey)
	if !ok {
		return nil, errors.New("error converting hdkey to curve25519")
	}

	ser, err := crypto.MarshalPrivateKey(childViewKey)
	if err != nil {
		return nil, err
	}

	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, nextIndex)
	if err := kc.ds.Put(context.Background(), datastore.NewKey(AddressIndexDatastoreKey), b); err != nil {
		return nil, err
	}
	if err := kc.ds.Put(context.Background(), datastore.NewKey(ViewKeyDatastoreKeyPrefix+strconv.Itoa(int(nextIndex))), ser); err != nil {
		return nil, err
	}

	kc.viewKeys = append(kc.viewKeys, &indexedViewKey{
		key:   curveViewKey,
		index: nextIndex,
	})

	script := types.UnlockingScript{
		SnarkVerificationKey: mockBasicUnlockScriptCommitment,
		PublicParams:         [][]byte{rawPublic},
	}

	return NewBasicAddress(script, childViewKey.PrivateKey().GetPublic(), kc.params)
}

func (kc *Keychain) Unlock(passphrase string, duration time.Duration) error {
	kc.mtx.Lock()
	defer kc.mtx.Unlock()

	if !kc.isEncrypted {
		return errors.New("keychain already unlocked")
	}

	ciphertext, err := kc.ds.Get(context.Background(), datastore.NewKey(MnemonicSeedDatastoreKey))
	if err != nil {
		return err
	}

	salt, err := kc.ds.Get(context.Background(), datastore.NewKey(KeyDatastoreSaltKey))
	if err != nil {
		return err
	}

	dk := pbkdf2.Key([]byte(passphrase), salt, defaultKdfRounds, defaultKeyLength, sha512.New)

	block, err := aes.NewCipher(dk)
	if err != nil {
		return err
	}

	// The IV needs to be unique, but not secure. Therefore it's common to
	// include it at the beginning of the ciphertext.
	if len(ciphertext) < aes.BlockSize {
		return errors.New("ciphertext too short")
	}
	iv := ciphertext[:aes.BlockSize]
	ciphertext = ciphertext[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)

	// XORKeyStream can work in-place if the two arguments are the same.
	stream.XORKeyStream(ciphertext, ciphertext)

	seed := bip39.NewSeed(string(ciphertext), "")

	kc.unencryptedSeed = seed
	kc.isEncrypted = false
	time.AfterFunc(duration, func() {
		kc.mtx.Lock()
		kc.isEncrypted = true
		kc.unencryptedSeed = nil
		kc.mtx.Unlock()
	})
	return nil
}

func (kc *Keychain) Lock() error {
	kc.mtx.Lock()
	defer kc.mtx.Unlock()

	if kc.isEncrypted {
		return errors.New("wallet is already locked")
	}

	kc.isEncrypted = true
	kc.unencryptedSeed = nil
	return nil
}

func (kc *Keychain) getViewKeys() []*indexedViewKey {
	kc.mtx.RLock()
	defer kc.mtx.RUnlock()

	return kc.viewKeys
}
